<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../../">
  <title data-ice="title">react-native-ble-plx/src/BleManager.js | API Document</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  
  
  <script src="script/manual.js"></script>
</head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <a data-ice="repoURL" href="https://github.com/Polidea/react-native-ble-plx" class="repo-url-github">Repository</a>
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
</header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><div data-ice="dirPath" class="nav-dir-path">src</div><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/react-native-ble-plx/src/BleManager.js~BleManager.html">BleManager</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/react-native-ble-plx/src/Characteristic.js~Characteristic.html">Characteristic</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/react-native-ble-plx/src/Device.js~Device.html">Device</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/react-native-ble-plx/src/Service.js~Service.html">Service</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-fullUUID">fullUUID</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">react-native-ble-plx/src/BleManager.js</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">// @flow
&apos;use strict&apos;;

import { NativeModules, NativeEventEmitter } from &apos;react-native&apos;;
import Device from &apos;./Device&apos;;
import Service from &apos;./Service&apos;;
import Characteristic from &apos;./Characteristic&apos;;
import { fullUUID } from &apos;./Utils&apos;;

const BleModule = NativeModules.BleClientManager;

export type State =
  &apos;Unknown&apos;
  | &apos;Resetting&apos;
  | &apos;Unsupported&apos;
  | &apos;Unauthorized&apos;
  | &apos;PoweredOff&apos;
  | &apos;PoweredOn&apos;

export type Subscription = {
  remove: () =&gt; void
}

export type ScanOptions = {
  allowDuplicates?: boolean,
  autoConnect?: boolean
}

export type ConnectionOptions = {
  // Not used for now
}


/**
 * 
 * BleManager is an entry point for react-native-ble-plx library. It provides all means to discover and work with
 * {@link Device} instances. It should be initialized only once with new keyword and method {@link destroy} should be called 
 * on its instance when user wants to deallocate all resources.
 * 
 * @example
 * const manager = new BleManager();
 * // ... work with BLE manager ...
 * manager.destroy(); 
 * 
 * @export
 * @class BleManager
 */
export default class BleManager {

  _scanEventSubscription: ?NativeEventEmitter
  _eventEmitter: NativeEventEmitter
  _uniqueId: number

  constructor() {
    BleModule.createClient();
    this._eventEmitter = new NativeEventEmitter(BleModule)
    this._uniqueId = 0
  }

  /**
   * Destroys BleManager instance. A new instance needs to be created to continue working with react-native-ble-plx.
   * 
   * @memberOf BleManager
   */
  destroy() {
    BleModule.destroyClient();
  }

  _nextUniqueID(): string {
    this._uniqueId += 1
    return this._uniqueId.toString()
  }

  // Mark: Common --------------------------------------------------------------------------------------------------------


  /**
   * Cancels pending transaction.
   * 
   * Few operations such as monitoring characteristic&apos;s value changes can be cancelled by a user. Basically every API 
   * entry which accepts `transactionId` allows to call `cancelTransaction` function. When cancelled operation is a 
   * promise or a callback which registers errors, `&quot;Cancelled&quot;` error will be emitted in that case.
   * 
   * Cancelling transaction which doesn&apos;t exist is ignored.
   * 
   * @param {string} transactionId Id of pending transactions.
   * 
   * @memberOf BleManager
   */
  cancelTransaction(transactionId: string) {
    BleModule.cancelTransaction(transactionId)
  }

  // Mark: Monitoring state ----------------------------------------------------------------------------------------------


  /**
   * Current state of a manager.
   * 
   * Available states:
   * - `Unknown` - the current state of the manager is unknown; an update is imminent.
   * - `Resetting` - the connection with the system service was momentarily lost; an update is imminent.
   * - `Unsupported` - the platform does not support Bluetooth low energy.
   * - `Unauthorized` - the app is not authorized to use Bluetooth low energy.
   * - `PoweredOff` - Bluetooth is currently powered off.
   * - `PoweredOn` - Bluetooth is currently powered on and available to use.
   * 
   * @returns {Promise&lt;State&gt;} Promise which emits current state of BleManager.
   * 
   * @memberOf BleManager
   */
  state(): Promise&lt;State&gt; {
    return BleModule.state()
  }

  /**
  * 
  * Notifies about state changes of a manager.
  * 
  * @param {function(newState: State)} listener Callback which emits state changes of BLE Manager. 
  * Look at {@link state} for possible values.
  * @param {boolean} [emitCurrentState=false] If true, current state will be emitted as well. Defaults to false.
  *  
  * @returns {Subscription} Subscription on which remove() function can be called to unsubscribe.
  * 
  * @memberOf BleManager
  */
  onStateChange(listener: (newState: State) =&gt; void, emitCurrentState: boolean = false): Subscription {
    const subscription = this._eventEmitter.addListener(BleModule.StateChangeEvent, listener);

    if (emitCurrentState) {
      var cancelled = false;
      this.state().then((currentState) =&gt; {
        if (!cancelled) {
          listener(currentState);
        }
      });

      return {
        remove: () =&gt; {
          cancelled = true;
          subscription.remove();
        }
      }
    }

    return subscription
  }

  // Mark: Scanning ------------------------------------------------------------------------------------------------------


  /**
   * Starts device scanning. 
   * 
   * When previous scan is in progress it will be stopped before executing this command.
   * 
   * @param {?string[]} UUIDs - Array of strings containing UUIDs of services which are registered in scanned devices. 
   * If null is passed all available devices will be scanned.
   * @param {?ScanOptions} options - Optional configuration for scanning operation. Scan option object contains two
   * optional fields: `allowDuplicates` for iOS when set to true scanned {@link Device}s will be emitted more
   * frequently, `autoConnect` for Android - allows to connect to devices which are not in range.
   * @param {function(error: ?Error, scannedDevice: ?Device)} listener - Function which will be called for every scanned 
   * {@link Device} (devices may be scanned multiple times). It&apos;s first argument is potential {@link Error} which is set 
   * to non `null` value when scanning failed. You have to start scanning process again if that happens. Second argument 
   * is a scanned {@link Device}.
   * 
   * @memberOf BleManager
   */
  startDeviceScan(UUIDs: ?string[], options: ?ScanOptions, listener: (error: ?Error, scannedDevice: ?Device) =&gt; void) {
    this.stopDeviceScan()
    const scanListener = ([error, device]) =&gt; {
      listener(error, device ? new Device(device, this) : null)
    };
    this._scanEventSubscription = this._eventEmitter.addListener(BleModule.ScanEvent, scanListener);
    BleModule.startDeviceScan(UUIDs, options);
  }


  /**
   * 
   * Stops device scan if in progress.
   * 
   * @memberOf BleManager
   */
  stopDeviceScan() {
    if (this._scanEventSubscription) {
      this._scanEventSubscription.remove()
      delete this._scanEventSubscription
    }
    BleModule.stopDeviceScan();
  }

  // Mark: Connection management -----------------------------------------------------------------------------------------

  /**
   * Connects to {@link Device} with provided ID.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {?ConnectionOptions} options - Platform specific options for connection establishment. Not used currently.
   * @returns {Promise&lt;Device&gt;} Connected {@link Device} object if successful.
   * 
   * @memberOf BleManager
   */
  async connectToDevice(deviceIdentifier: string, options: ?ConnectionOptions): Promise&lt;Device&gt; {
    const deviceProps = await BleModule.connectToDevice(deviceIdentifier, options);
    return new Device(deviceProps, this);
  }


  /**
   * Disconnects from device if it&apos;s connected or cancels pending connection.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier to be closed. 
   * @returns {Promise&lt;Device&gt;} Returns closed {@link Device} when operation is successful.
   * 
   * @memberOf BleManager
   */
  async cancelDeviceConnection(deviceIdentifier: string): Promise&lt;Device&gt; {
    const deviceProps = await BleModule.cancelDeviceConnection(deviceIdentifier);
    return new Device(deviceProps, this);
  }


  /**
   * Monitors if device was disconnected due to any errors or connection problems.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier to be monitored.
   * @param {function(error: ?Error, device: Device)} listener - callback returning error as a reason of disconnection 
   * if available and {@link Device} object.
   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.
   * 
   * @memberOf BleManager
   */
  onDeviceDisconnected(deviceIdentifier: string, listener: (error: ?Error, device: Device) =&gt; void): Subscription {
    const disconnectionListener = ([error, device]) =&gt; {
      if (deviceIdentifier !== device.id) return
      listener(error, device)
    };

    const subscription = this._eventEmitter.addListener(BleModule.DisconnectionEvent, disconnectionListener);
    return subscription
  }

  /**
   * Check connection state of a device.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @returns {Promise&lt;boolean&gt;} - Promise which emits `true` if device is connected, and `false` otherwise.
   * 
   * @memberOf BleManager
   */
  async isDeviceConnected(deviceIdentifier: string): Promise&lt;boolean&gt; {
    return BleModule.isDeviceConnected(deviceIdentifier)
  }

  // Mark: Discovery -------------------------------------------------------------------------------------------------

  /**
   * Discovers all services and characteristics for {@link Device}.
   * 
   * @param {string} identifier - {@link Device} identifier.
   * @returns {Promise&lt;Device&gt;} - Promise which emits {@link Device} object if all available services and 
   * characteristics have been discovered.
   * 
   * @memberOf BleManager
   */
  async discoverAllServicesAndCharacteristicsForDevice(identifier: string): Promise&lt;Device&gt; {
    const deviceProps = await BleModule.discoverAllServicesAndCharacteristicsForDevice(identifier)
    return new Device(deviceProps, this)
  }

  // Mark: Service and characteristic getters ------------------------------------------------------------------------

  /**
   * List of discovered services for device.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @returns {Promise&lt;Service[]&gt;} - Promise which emits array of {@link Service} objects which are discovered for a 
   * {@link Device}.
   * 
   * @memberOf BleManager
   */
  async servicesForDevice(deviceIdentifier: string): Promise&lt;Service[]&gt; {
    const services = await BleModule.servicesForDevice(deviceIdentifier)
    return services.map((serviceProps) =&gt; { return new Service(serviceProps, this) })
  }

  /**
   * List of discovered characteristics for given {@link Device} and {@link Service}.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {string} serviceUUID - {@link Service} UUID.
   * @returns {Promise&lt;Characteristic[]&gt;} - Promise which emits array of {@link Characteristic} objects which are 
   * discovered for a {@link Device} in specified {@link Service}.
   * 
   * @memberOf BleManager
   */
  async characteristicsForDevice(deviceIdentifier: string, serviceUUID: string): Promise&lt;Characteristic[]&gt; {
    const characteristics = await BleModule.characteristicsForDevice(deviceIdentifier, serviceUUID);
    return characteristics.map((characteristicProps) =&gt; { return new Characteristic(characteristicProps, this) });
  }

  // Mark: Characteristics operations --------------------------------------------------------------------------------

  /**
   * Read characteristic value.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {string} serviceUUID - {@link Service} UUID.
   * @param {string} characteristicUUID - {@link Characteristic} UUID.
   * @param {?string} transactionId - optional `transactionId` which can be used in {@link cancelTransaction} function.
   * @returns {Promise&lt;Characteristic&gt;} - Promise which emits first {@link Characteristic} object matching specified 
   * UUID paths. Latest value of {@link Characteristic} will be stored inside returned object.
   * 
   * @memberOf BleManager
   */
  async readCharacteristicForDevice(
    deviceIdentifier: string,
    serviceUUID: string,
    characteristicUUID: string,
    transactionId: ?string): Promise&lt;Characteristic&gt; {
    if (!transactionId) {
      transactionId = this._nextUniqueID()
    }

    const characteristicProps = await BleModule.readCharacteristicForDevice(deviceIdentifier,
      serviceUUID,
      characteristicUUID,
      transactionId);
    return new Characteristic(characteristicProps, this)
  }

  /**
   * Write characteristic value with response.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {string} serviceUUID - {@link Service} UUID.
   * @param {string} characteristicUUID - {@link Characteristic} UUID.
   * @param {string} base64Value - Value in Base64 format.
   * @param {?string} transactionId - optional `transactionId` which can be used in {@link cancelTransaction} function.
   * @returns {Promise&lt;Characteristic&gt;} - Promise which emits first {@link Characteristic} object matching specified 
   * UUID paths. Latest value of characteristic may not be stored inside returned object.
   * 
   * @memberOf BleManager
   */
  async writeCharacteristicWithResponseForDevice(
    deviceIdentifier: string,
    serviceUUID: string,
    characteristicUUID: string,
    base64Value: string,
    transactionId: ?string): Promise&lt;Characteristic&gt; {
    if (!transactionId) {
      transactionId = this._nextUniqueID()
    }

    const characteristicProps = await BleModule.writeCharacteristicForDevice(deviceIdentifier,
      serviceUUID,
      characteristicUUID,
      base64Value,
      true,
      transactionId);
    return new Characteristic(characteristicProps, this)
  }


  /**
   * Write characteristic value without response.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {string} serviceUUID - {@link Service} UUID.
   * @param {string} characteristicUUID - {@link Characteristic} UUID.
   * @param {string} base64Value - Value in Base64 format.
   * @param {?string} transactionId - optional `transactionId` which can be used in {@link cancelTransaction} function.
   * @returns {Promise&lt;Characteristic&gt;} - Promise which emits first {@link Characteristic} object matching specified 
   * UUID paths. Latest value of characteristic may not be stored inside returned object.
   * 
   * @memberOf BleManager
   */
  async writeCharacteristicWithoutResponseForDevice(
    deviceIdentifier: string,
    serviceUUID: string,
    characteristicUUID: string,
    base64Value: string,
    transactionId: ?string): Promise&lt;Characteristic&gt; {
    if (!transactionId) {
      transactionId = this._nextUniqueID()
    }

    const characteristicProps = await BleModule.writeCharacteristicForDevice(deviceIdentifier,
      serviceUUID,
      characteristicUUID,
      base64Value,
      false,
      transactionId);
    return new Characteristic(characteristicProps, this)
  }


  /**
   * Monitor value changes of a characteristic. If notifications are enabled they will be used
   * in favour of indications.
   * 
   * @param {string} deviceIdentifier - {@link Device} identifier.
   * @param {string} serviceUUID - {@link Service} UUID.
   * @param {string} characteristicUUID - {@link Characteristic} UUID.
   * @param {function(error: ?Error, characteristic: ?Characteristic)} listener - callback which emits 
   * {@link Characteristic} objects with modified value for each notification.
   * @param {?string} transactionId - optional `transactionId` which can be used in {@link cancelTransaction} function.
   * @returns {Subscription} Subscription on which `remove()` function can be called to unsubscribe.
   * 
   * @memberOf BleManager
   */
  monitorCharacteristicForDevice(deviceIdentifier: string,
    serviceUUID: string,
    characteristicUUID: string,
    listener: (error: ?Error, characteristic: ?Characteristic) =&gt; void,
    transactionId: ?string): Subscription {
    if (!transactionId) {
      transactionId = this._nextUniqueID()
    }

    const monitorListener = ([error, characteristic, msgTransactionId]) =&gt; {
      if (transactionId !== msgTransactionId) return
      if (error) {
        listener(error, null)
        return
      }
      listener(null, new Characteristic(characteristic, this))
    };

    const subscription = this._eventEmitter.addListener(BleModule.ReadEvent, monitorListener);
    BleModule.monitorCharacteristicForDevice(deviceIdentifier, serviceUUID, characteristicUUID, transactionId)
      .then((finished) =&gt; {
        subscription.remove()
      }, (error) =&gt; {
        listener(error, null)
        subscription.remove()
      })

    return {
      remove: () =&gt; {
        BleModule.cancelTransaction(transactionId)
      }
    }
  }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(0.5.2)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
